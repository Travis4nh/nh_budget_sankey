#!/usr/bin/env ruby

# usage:
#    ./sankey.rb > sankey_data.txt
#

require 'csv'

# Example of parsing a CSV file
$csv_file_path = './Governor-FY24_25-Recommended-Budget.csv'

header_row_number = 5
$headers = []

rows = CSV.read($csv_file_path)

rows.each_with_index do |row, ii|
  if ii == header_row_number
    $headers = row
    break
  end
end

$flows = Hash.new{ |hash, key| hash[key] = Hash.new(0) }
$spending_classes = Set.new
$departments_scaled = Hash.new

def add_flow(source, dest, amt)
  $flows[source][dest] += amt
end

def populate_flow_data
  ii = 0
  CSV.foreach( $csv_file_path , headers: $headers) do |row|
    ii += 1
    next unless ii > 6

    amt = row['FY22 Actual '].to_i
    fund = row['Fund']
    cat = row['Category of Government']
    dept = row['Department']
    agency = row['Agency']
    activity = row['Activity']
    spending_class = row['Class']

    if row['Record Type'] == "Expense"
      $spending_classes.add(spending_class)
      


      add_flow(fund, cat, amt)
      add_flow(cat, dept, amt)
      add_flow(dept, agency, amt)
      # add_flow(agency, activity, amt)
      add_flow(agency, spending_class, amt)

    elsif row['Record Type'] == "Funding"
    # puts " funding"
    elsif row['Record Type'] == "Position"
    # puts " position"
    else
      raise "unknown record type `#{row['Record Type']}`"
    end
    
  end

end

def output_flow_data
  $flows.each_pair do |src, details|
    details.each_pair do |dest, amt|
      puts " #{src} [#{amt}] #{dest} "
    end
  end
end

def scale_depts

  # puts "$spending_classes = #{$spending_classes.inspect}"
  
  departments = Hash.new{ |hash, key| hash[key] = Hash.new(0) }
  
  $flows.each_pair do |src, details|
    details.each_pair do |dest, amt|
      # is the flow is from an acct_class to a class (lead node)
      if $spending_classes.include?(dest)
        # dest_sym = dest.downcase.gsub(/[ -]/, '_').to_sym
        departments[src][dest] = amt
      end
    end
  end

  # puts "departments = #{departments.inspect}"

  $departments_scaled = Hash.new

  departments.each_pair do |dept, hh|

    total = hh.to_a.inject(0) { |sum, pair| sum + pair[1] }
    next if total == 0
    scaled_h = hh.to_a.map { |expense_name, spending_dollars| [expense_name, spending_dollars * 1.0 / total ] }.to_h

    # puts "-------------------- #{dept}"
    # puts "raw = #{hh.inspect}"
    # puts "sum percent = #{ scaled_h.map { |k,v| v }.sum }"
    # scaled_h[:total] = total
    # puts "scaled = #{scaled_h.inspect}"

    $departments_scaled[dept] = scaled_h
    
  end
end

# Look at data from the spending-class perspective (e.g. IT, overtime, out-of-state travel, etc.)
# For each spending category, report on which departments
#
def calculate_class_percents

  $spending_classes.to_a.sort.each do |sp_class|

    
    #puts departments_scaled.map { |k, hh| [ k, hh[sp_class] ] }.inspect
    arr = departments_scaled.map { |k, hh| [ k, hh[sp_class] || 0.0 ] }.sort_by { | pair | pair[1] }.reverse
    avg = arr.map { |pair| pair[1] }.sum / arr.length

    variance_array = arr.map{|pair| (pair[1] - avg) }
    std_dev = variance_array.size == 0 ? 0 :   Math.sqrt(variance_array.sum { |v| v ** 2} / variance_array.size)

    
    puts "---- #{sp_class} avg = #{sprintf("%3.2f", avg * 100)}%, std_dev = #{sprintf("%2.2f", std_dev * 100)} percentage pts "

    if arr.reject { |k, v| v == 0.0 }.length < 3
      puts "skipped bc too few"
      next
    end
    
    # puts "arr = #{arr.inspect}"


    arr[0,10].each do |pair|
      devs = (pair[1] - avg) / std_dev
      puts "  * #{sprintf("%5.2f", pair[1] * 100) }% + #{ sprintf("%2.0f", devs) } std devs    #{pair[0] }"
    end
  end
  
end

def print_dept_percents

  $departments_scaled.each_pair do |dept, hh|
    puts "---- #{dept}"
    hh.to_a.sort_by { |pair| pair[1]}.reverse[0,10].each do |pair|
      puts "  * #{sprintf("%5.1f", pair[1] * 100)}% #{pair[0]}"
    end
    puts "\n"
  end  

  $departments_scaled.each_pair do |dept, hh|
    filename_base = "/tmp/" + dept.gsub(/[ &:]/, "-").gsub(/-+/, "-").downcase

    filename_pie = filename_base + ".pie"
    file = File.open(filename_pie, "w")
    hh.to_a.sort_by { |pair| pair[1]}.reverse[0,10].each do |pair|
      file.write("#{sprintf("%5.1f", pair[1] * 100)},#{pair[0].gsub(/&/, "and")}\n")
    end
    file.close

    filename_svg = filename_base + ".svg"
    filename_annotated = filename_base + ".png"
    
    pie_cmd = "piechart  --percent  --order value,legend --color contrast #{filename_pie} > #{filename_svg}"
    `#{pie_cmd}`
    convert_cmd = "convert #{filename_svg} -gravity north -extent 900x700 -pointsize 50 -fill black  -annotate +0+600 \"#{dept.downcase}\"  #{filename_annotated}"
    `#{convert_cmd}`
    puts "create pie chart #{filename_annotated}"

  end  

  
end



## top-level functions

task :sankey do
  populate_flow_data
  write_sankey_file
  
  file = File.open("./sankey_display_settings.txt", "r")
  contents = file.read
  puts contents
end

task :analyze do
  populate_flow_data
  scale_depts
  calculate_class_percents
end

task :department do
  populate_flow_data
  scale_depts
  print_dept_percents
end
